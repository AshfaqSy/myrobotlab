package org.myrobotlab.arduino;


import java.io.ByteArrayOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicInteger;

import org.myrobotlab.logging.Level;

import org.myrobotlab.arduino.virtual.MrlComm;
import org.myrobotlab.string.StringUtil;

/**
 * <pre>
 * 
 Welcome to Msg.java
 Its created by running ArduinoMsgGenerator
 which combines the MrlComm message schema (src/resource/Arduino/arduinoMsg.schema)
 with the cpp template (src/resource/Arduino/generate/Msg.java.template)

   Schema Type Conversions

  Schema      ARDUINO          Java              Range
  none    byte/unsigned char    int (cuz Java byte bites)    1 byte - 0 to 255
  boolean    boolean          boolean              0 1
    b16      int            int (short)            2 bytes  -32,768 to 32,767
    b32      long          int                4 bytes -2,147,483,648 to 2,147,483, 647
    bu32    unsigned long      long              0 to 4,294,967,295
    str      char*, size        String              variable length
    []      byte[], size      int[]              variable length

 All message editing should be done in the arduinoMsg.schema

 The binary wire format of an %javaArduinoClass% is:

 MAGIC_NUMBER|MSG_SIZE|METHOD_NUMBER|PARAM0|PARAM1 ...
 
 </pre>

 */

import org.myrobotlab.logging.LoggerFactory;
import org.myrobotlab.logging.LoggingFactory;
import org.myrobotlab.service.VirtualArduino;

import java.io.FileOutputStream;
import java.util.Arrays;
import org.myrobotlab.service.interfaces.MrlCommListener;
import org.myrobotlab.service.Runtime;
import org.myrobotlab.service.Servo;
import org.myrobotlab.service.interfaces.SerialDevice;
import org.slf4j.Logger;

/**
 * Singlton messaging interface to an %javaArduinoClass%
 *
 * @author GroG
 *
 */

public class %javaClass% {

  public static final int MAX_MSG_SIZE = 64;
  public static final int MAGIC_NUMBER = 170; // 10101010
  public static final int MRLCOMM_VERSION = %MRLCOMM_VERSION%;
  
  int ackMaxWaitMs = 1000;
  
    boolean waiting = false;
  
  
  // send buffer
  int sendBufferSize = 0;
  int sendBuffer[] = new int[MAX_MSG_SIZE];
  
  // recv buffer
  int ioCmd[] = new int[MAX_MSG_SIZE];
  
  AtomicInteger byteCount = new AtomicInteger(0);
  int msgSize = 0;

  // ------ device type mapping constants
  int method = -1;
  public boolean debug = false;
  boolean invoke = true;
  
  private int errorServiceToHardwareRxCnt = 0;
  private int errorHardwareToServiceRxCnt = 0;
  
  boolean ackEnabled = %ackEnabled%;
  private ByteArrayOutputStream baos = null;
  public volatile boolean pendingMessage = false;
  private volatile boolean clearToSend = false;
    
  public static class AckLock {
    // first is always true - since there
    // is no msg to be acknowledged...
    volatile boolean acknowledged = true;
  }
   
  transient AckLock ackRecievedLock = new AckLock();
  
  // recording related
  transient FileOutputStream record = null;
  transient StringBuilder rxBuffer = new StringBuilder();
  transient StringBuilder txBuffer = new StringBuilder();  

%javaDeviceTypes%    
%javaDefines%

/**
 * These methods will be invoked from the Msg class as callbacks from MrlComm.
 */
  
%javaGeneratedCallBacks%  

  
  public transient final static Logger log = LoggerFactory.getLogger(Msg.class);

  public %javaClass%(%javaArduinoClass% arduino, SerialDevice serial) {
    this.arduino = arduino;
    this.serial = serial;
  }
  
  public void begin(SerialDevice serial){
    this.serial = serial;
  }

  // transient private Msg instance;

  // ArduinoSerialCallBacks - TODO - extract interface
  transient private %javaArduinoClass% arduino;
  
  transient private SerialDevice serial;
  
  public void setInvoke(boolean b){
    invoke = b;
  }
  
  public void processCommand(){
    processCommand(ioCmd);
  }
  
  public void processCommand(int[] ioCmd) {
    int startPos = 0;
    method = ioCmd[startPos];
    // always process mrlbegin.. 
    log.info("Process Command: {} Method: {}", Msg.methodToString(method), ioCmd);
    if (method != PUBLISH_MRL_COMM_BEGIN) {
      if (!clearToSend) {
        log.warn("Not Clear to send yet.  Dumping command {}", ioCmd);
        System.err.println("\nDumping command not clear to send.\n");
        return;
      }
    } else {
      // Process!
      log.info("Clear to process!!!!!!!!!!!!!!!!!!");
      this.clearToSend = true;
    }
    switch (method) {
%javaHandleCases%    
    }
  }
  

  // Java-land --to--> MrlComm
%javaMethods%

  public static String methodToString(int method) {
    switch (method) {
%methodToString%
    default: {
      return "ERROR UNKNOWN METHOD (" + Integer.toString(method) + ")";

    } // default
    }
  }

  public String str(int[] buffer, int start, int size) {
    byte[] b = new byte[size];
    for (int i = start; i < start + size; ++i){
      b[i - start] = (byte)(buffer[i] & 0xFF);
    }
    return new String(b);
  }

  public int[] subArray(int[] buffer, int start, int size) {    
    return Arrays.copyOfRange(buffer, start, start + size);
  }

  // signed 16 bit bucket
  public int b16(int[] buffer, int start/*=0*/) {
    return  (short)(buffer[start] << 8) + buffer[start + 1];
  }
  
  // signed 32 bit bucket
  public int b32(int[] buffer, int start/*=0*/) {
    return ((buffer[start + 0] << 24) + (buffer[start + 1] << 16)
        + (buffer[start + 2] << 8) + buffer[start + 3]);
  }
  
  // unsigned 32 bit bucket
  public long bu32(int[] buffer, int start/*=0*/) {
    long ret = ((buffer[start + 0] << 24)
        + (buffer[start + 1] << 16)
        + (buffer[start + 2] << 8) + buffer[start + 3]);
    if (ret < 0){
      return 4294967296L + ret;
    }
    
    return ret;
  }

  // float 32 bit bucket
  public float f32(int[] buffer, int start/*=0*/) {
    byte[] b = new byte[4];
    for (int i = 0; i < 4; ++i){
      b[i] = (byte)buffer[start + i];
    }
    float f = ByteBuffer.wrap(b).order(ByteOrder.BIG_ENDIAN).getFloat();
    return f;
  }
  
  public void onBytes(byte[] bytes) {
    // TODO: This is a debug message only...
    String byteString = StringUtil.byteArrayToIntString(bytes);
    log.info("onBytes called byteCount: {} data: >{}<", byteCount, byteString);
    // this gives us the current full buffer that was read from the seral
    for (int i = 0 ; i < bytes.length; i++) {
      // For now, let's just call onByte for each byte upcasted as an int.
      Integer newByte = bytes[i] & 0xFF;
      try {
        /**
         * Archtype InputStream read - rxtxLib does not have this straightforward
         * design, but the details of how it behaves is is handled in the Serial
         * service and we are given a unified interface
         *
         * The "read()" is data taken from a blocking queue in the Serial service.
         * If we want to support blocking functions in Arduino then we'll
         * "publish" to our local queues
         */
        // TODO: consider reading more than 1 byte at a time ,and make this
        // callback onBytes or something like that.
        byteCount.incrementAndGet();
        
        // log.info("{} Byte Count {} MsgSize: {} On Byte: {}", i, byteCount, msgSize, newByte);
        // ++byteCount;
        if (log.isDebugEnabled()) {
          log.info("onByte {} \tbyteCount \t{}", newByte, byteCount);
        }
        if (byteCount.get() == 1) {
          if (newByte != MAGIC_NUMBER) {
            byteCount = new AtomicInteger(0);
            msgSize = 0;
            Arrays.fill(ioCmd, 0); // FIXME - optimize - remove
            // warn(String.format("Arduino->MRL error - bad magic number %d - %d rx errors", newByte, ++errorServiceToHardwareRxCnt));
            log.warn("Arduino->MRL error - bad magic number {} - {} rx errors", newByte, ++errorServiceToHardwareRxCnt);
            // dump.setLength(0);
          }
          continue;
        } else if (byteCount.get() == 2) {
          // get the size of message
          if (newByte > 64) {
            byteCount = new AtomicInteger(0);
            msgSize = 0;
            // This is an error scenario.. we should reset our byte count also.
            // error(String.format("Arduino->MRL error %d rx sz errors", ++errorServiceToHardwareRxCnt ));
            log.error("Arduino->MRL error {} rx sz errors", ++errorServiceToHardwareRxCnt);
            continue;
          }
          msgSize = newByte.intValue();
          // dump.append(String.format("MSG|SZ %d", msgSize));
        } else if (byteCount.get() == 3) {
          // This is the method..
          int method = newByte.intValue();
          // TODO: lookup the method in the label.. 
          if (!clearToSend) {
            // The only method we care about is begin!!!
            if (method != Msg.PUBLISH_MRL_COMM_BEGIN) {
              // This is a reset sort of scenario!  we should be killing our parser state
              // we are only looking for a begin message now!!
              byteCount = new AtomicInteger(0);
              msgSize = 0;
              continue;
            } else {
              // we're good to go.. maybe even clear to send at this point?
            }
          }
          if (methodToString(method).startsWith("ERROR")) {
            // we've got an error scenario here.. reset the parser and try again!
            log.error("Arduino->MRL error unknown method error. resetting parser.");
            byteCount = new AtomicInteger(0);
            msgSize = 0;
            if (isFullMessage(bytes)) {
              // TODO: This could be an infinite loop 
              // try to reprocess this byte array, maybe the parser got out of sync
              onBytes(bytes);
              return;
            }
            
          } else {
            ioCmd[byteCount.get() - 3] = method;
          }
        } else if (byteCount.get() > 3) {
          // remove header - fill msg data - (2) headbytes -1
          // (offset)
          // dump.append(String.format("|P%d %d", byteCount,
          // newByte));
          ioCmd[byteCount.get() - 3] = newByte.intValue();
        } else {
          // the case where byteCount is negative?! not got.
          log.warn("MRL error rx zero/negative size error: {} {}", byteCount, Arrays.copyOf(ioCmd, byteCount.get()));
          //error(String.format("Arduino->MRL error %d rx negsz errors", ++errorServiceToHardwareRxCnt));
          continue;
        }
        if (byteCount.get() == 2 + msgSize) {
          // we've received a full message
          int[] actualCommand = Arrays.copyOf(ioCmd, byteCount.get()-2);
          log.info("Full message received: {} Data:{}", VirtualMsg.methodToString(ioCmd[0]), actualCommand);
          // TODO: should we truncate our ioCmd that we send here?  the ioCmd array is larger than the message in almost all cases.
          // re-init the parser
          // TODO: this feels very thread un-safe!
          Arrays.fill(ioCmd, 0); // optimize remove
          // process the command.
          
          // This full command that we received. 
          
          processCommand(actualCommand);
          // we should only process this command if we are clear to sync.. 
          // if this is a begin command..  
//          if (!clearToSend) {
//            // if we're not clear to send.. we need to process this command
//            // only if it's a begin command.
//            if (isMrlCommBegin(actualCommand)) {
//              processCommand(actualCommand);
//            } else {
//              // reset the parser and attempt from the next byte
//              // TODO: check that it's not bytes.length-1
//              byte[] shiftedBytes = Arrays.copyOfRange(bytes, 1, bytes.length);
//              byteCount = new AtomicInteger(0);
//              onBytes(shiftedBytes);
//              return;
//            }
//            
//          } else {
//            processCommand(actualCommand);
//          }
          msgSize = 0;
          byteCount = new AtomicInteger(0);
          // Our 'first' getBoardInfo may not receive a acknowledgement
          // so this should be disabled until boadInfo is valid
          // clean up memory/buffers
          
        }
      } catch (Exception e) {
        ++errorHardwareToServiceRxCnt ;
        // error("msg structure violation %d", errorHardwareToServiceRxCnt);
        log.warn("msg_structure violation byteCount {} buffer {}", byteCount, Arrays.copyOf(ioCmd, byteCount.get()), e);
        // try again (clean up memory buffer)
        // Logging.logError(e);
        
        // perhpas we could find the first occurance of 170.. and then attempt to re-parse at that point.
        // find the first occurance of 170 in the bytes
        // subbytes
        // Maybe we can just walk the iterater back to the beginning based on the byte count .. and advance it by 1.. and continue.
        i = i - byteCount.get()+1;
        log.error("Trying to resume parsing the byte stream at position {} bytecount: {}", i, byteCount);
        log.error("Original Byte Array: {}", StringUtil.byteArrayToIntString(bytes));
        System.err.println("Try to consume more messages!");
        msgSize = 0;
        byteCount = new AtomicInteger(0);
        // attempt to reprocess from the beginngin
        // TODO: what about infinite loops!!!
        i = 0;
        return;
        
        
      }
    }
    // log.info("Done with onBytes method.");
    return;
  }

  String F(String msg) {
    return msg;
  }
  
  public void publishError(String error) {
    log.error(error);
  }
  
  void appendMessage(int b8) throws Exception {

    if ((b8 < 0) || (b8 > 255)) {
      log.error("writeByte overrun - should be  0 <= value <= 255 - value = {}", b8);
    }

        baos.write(b8 & 0xFF);
//    serial.write(b8 & 0xFF);
  }
  
  void startMessage() {
    baos = new ByteArrayOutputStream();
  }

  void appendMessagebool(boolean b1) throws Exception {
    if (b1) {
      appendMessage(1);
    } else {
      appendMessage(0);
    }
  }

  void appendMessageb16(int b16) throws Exception {
    if ((b16 < -32768) || (b16 > 32767)) {
      log.error("writeByte overrun - should be  -32,768 <= value <= 32,767 - value = {}", b16);
    }

    appendMessage(b16 >> 8 & 0xFF);
    appendMessage(b16 & 0xFF);
  }

  void appendMessageb32(int b32) throws Exception {
    appendMessage(b32 >> 24 & 0xFF);
    appendMessage(b32 >> 16 & 0xFF);
    appendMessage(b32 >> 8 & 0xFF);
    appendMessage(b32 & 0xFF);
  }
  
  void appendMessagef32(float f32) throws Exception {
    //  int x = Float.floatToIntBits(f32);
    byte[] f = ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN).putFloat(f32).array();
    appendMessage(f[3] & 0xFF);
    appendMessage(f[2] & 0xFF);
    appendMessage(f[1] & 0xFF);
    appendMessage(f[0] & 0xFF);
  }
  
  void appendMessagebu32(long b32) throws Exception {
    appendMessage((int)(b32 >> 24 & 0xFF));
    appendMessage((int)(b32 >> 16 & 0xFF));
    appendMessage((int)(b32 >> 8 & 0xFF));
    appendMessage((int)(b32 & 0xFF));
  }

  void appendMessage(String str) throws Exception {
    appendMessage(str.getBytes());
  }

  void appendMessage(int[] array) throws Exception {
    // write size
    appendMessage(array.length & 0xFF);

    // write data
    for (int i = 0; i < array.length; ++i) {
      appendMessage(array[i] & 0xFF);
    }
  }

  void appendMessage(byte[] array) throws Exception {
    // write size
    appendMessage(array.length);

    // write data
    for (int i = 0; i < array.length; ++i) {
      appendMessage(array[i]);
    }
  }
  
  synchronized byte[] sendMessage() throws Exception {
    byte[] message = baos.toByteArray();
    if (ackEnabled) {
      // wait for any outstanding pending messages.
      while (pendingMessage) {
        Thread.sleep(1);
        log.info("Pending message");
      }
      // set a new pending flag.
      pendingMessage=true;
    }
    // write data if serial not null.
    if (serial != null) {
      serial.write(message);
    }
    return message;
  }
  
  public boolean isRecording() {
    return record != null;
  }
  

  public void record() throws Exception {
    
    if (record == null) {
      record = new FileOutputStream(String.format("%s.ard", arduino.getName()));
    }
  }

  public void stopRecording() {
    if (record != null) {
      try {
        record.close();
      } catch (Exception e) {
      }
      record = null;
    }
  }
  
  public static String deviceTypeToString(int typeId) {
    switch(typeId){
%deviceTypeToString%    
    default: {
      return "unknown";
    }
    }
  }
  
  public void enableAcks(boolean b){
    // disable local blocking
    ackEnabled = b;
    // if (!localOnly){
    // shutdown MrlComm from sending acks
    // below is a method only in Msg.java not in VirtualMsg.java
    // it depends on the definition of enableAck in arduinoMsg.schema  
    // %enableAck%
    // }
  }
  
  public void waitForAck(){
    if (!ackEnabled || ackRecievedLock.acknowledged){
      return;
    }
    synchronized (ackRecievedLock) {
      try {
        long ts = System.currentTimeMillis();
        // log.info("***** starting wait *****");
        ackRecievedLock.wait(2000);
        // log.info("*****  waited {} ms *****", (System.currentTimeMillis() - ts));
      } catch (InterruptedException e) {// don't care}
      }

      if (!ackRecievedLock.acknowledged) {
        //log.error("Ack not received : {} {}", Msg.methodToString(ioCmd[0]), numAck);
        log.error("Ack not received");
        // part of resetting ?
        // ackRecievedLock.acknowledged = true;
        arduino.invoke("noAck");
      }
    }
  }
  
  public void ackReceived(int function){
     synchronized (ackRecievedLock) {
        ackRecievedLock.acknowledged = true;
        ackRecievedLock.notifyAll();
      }
  }
  
  public int getMethod(){
    return method;
  }
  

  public void add(int value) {
    sendBuffer[sendBufferSize] = (value & 0xFF);
    sendBufferSize += 1;
  }
  
  public int[] getBuffer() {    
    return sendBuffer;
  }
  
  public static void main(String[] args) {
    try {

      // FIXME - Test service started or reference retrieved
      // FIXME - subscribe to publishError
      // FIXME - check for any error
      // FIXME - basic design - expected state is connected and ready -
      // between classes it
      // should connect - also dumping serial comm at different levels so
      // virtual arduino in
      // Python can model "real" serial comm
      String port = "COM10";

      LoggingFactory.init(Level.INFO);
      
      /*
      Runtime.start("gui","SwingGui");
      VirtualArduino virtual = (VirtualArduino)Runtime.start("varduino","VirtualArduino");
      virtual.connectVirtualUart(port, port + "UART");
      */
      
      %javaArduinoClass% arduino = (%javaArduinoClass%)Runtime.start("arduino","%javaArduinoClass%");
      Servo servo01 = (Servo)Runtime.start("servo01","Servo");
      
      /*
      arduino.connect(port);
      
      // test pins
      arduino.enablePin(5);
      
      arduino.disablePin(5);
      
      // test status list enabled
      arduino.enableBoardStatus(true);
      
      servo01.attach(arduino, 8);
      
      servo01.moveTo(30);
      servo01.moveTo(130);
      
      arduino.enableBoardStatus(false);
      */
      // test ack
      
      // test heartbeat
      
      

    } catch (Exception e) {
      log.error("main threw", e);
    }

  }

  public void waitForBegin() {
    // poll until a begin MrlComm Message has been seen.
    log.info("Wait for Begin called in Msg.");
    while (!clearToSend ) {
      // TODO: don't sleep. rather notify
      try {
        Thread.sleep(1);
      } catch (InterruptedException e) {
        log.info("Wait for MrlCommBegin interrupted.", e);
      }
    }
  }

  public synchronized void onConnect(String portName) {
    // reset the parser...
    log.info("On Connect Called in Msg.");
    this.byteCount = new AtomicInteger(0);
    this.msgSize = 0;
    // we're not clear to send.
    this.clearToSend = false;
    // watch for the first MrlCommBegin message;
    // TODO: we should have some sort of timeout / error handling here.
    // this.waitForBegin();
    
  }


  private boolean isMrlCommBegin(int[] actualCommand) {
    // TODO Auto-generated method stub
    int method = actualCommand[0];
    if (Msg.PUBLISH_MRL_COMM_BEGIN == method) {
      return true;
    }
    return false;
  }

  public static boolean isFullMessage(byte[] bytes) {
    // Criteria that a sequence of bytes could be parsed as a complete message.
    // can't be null
    if (bytes == null) 
      return false;
    // it's got to be at least 3 bytes long.  magic + method + size
    if (bytes.length <= 2) 
      return false;
    // first byte has to be magic
    if ((bytes[0] & 0xFF) != Msg.MAGIC_NUMBER) 
      return false;
    
    int method = bytes[1] & 0xFF;
    String strMethod = Msg.methodToString(method); 
    // only known methods. 
    // TODO: make the methodToString return null for an unknown lookup.
    if (strMethod.startsWith("ERROR")) 
      return false;
    
    // now it's got to be the proper length
    int length = bytes[1] & 0xFF;
    // max message size is 64 bytes
    if (length > 64)
      return false;

    // it's a exactly a full message or a message and more.
    if (bytes.length >= length+2)
      return true;

    
    return false;
  }

  public boolean isClearToSend() {
    return clearToSend;
  }

}
